#!/usr/bin/env Rscript

suppressPackageStartupMessages(require(argparse))
suppressPackageStartupMessages(require(GISAIDR))

DATABASES  <- c("EpiCoV", "EpiPox", "EpiRSV")
VERSION    <- paste(packageVersion("GISAIDR"))
DATE_REGEX <- "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"

parser = argparse::ArgumentParser(prog='GISAIDR', add_help=TRUE)

# Mandatory Options
args_mandatory = parser$add_argument_group('MANDATORY OPTIONS')
args_mandatory$add_argument('--credentials', default=NULL, help="Path to yaml file with GISAID credentials. Required If GISAIDR_USERNAME and GISAIDR_PASSWORD are not defined as environment variables.")
args_mandatory$add_argument('--database',    default=NULL, help=paste0("GISAID database name ( ", paste(DATABASES, collapse=", "), " )."))

# Output Options
args_output = parser$add_argument_group('OUTPUT OPTIONS')
args_output$add_argument('--augur-input',           action="store_true", help='Augur input metadata and sequences.')
args_output$add_argument('--dates-and-location',    action="store_true", help='Dates and location metadata.')
args_output$add_argument('--ids',                   action="store_true", help='Accession IDs.')
args_output$add_argument('--order-by',              type="character",    help="Order the final metadata by this column. Note: sequences will not follow this order.")
args_output$add_argument('--order-by-rev',          action="store_true", help="Reverse the order of the final metadata.")
args_output$add_argument('--patient-status',        action="store_true", help='Patient status metadata.')
args_output$add_argument('--prefix',                type="character",    default=NULL, help="Optional prefix for output files. If not provided, ids will be save to 'ids.txt', metadata to 'metadata.tsv', and sequences to 'sequences.fasta'.")
args_output$add_argument('--sequences',             action="store_true", help='Nucleotide sequences fasta.')
args_output$add_argument('--sequencing-technology', action="store_true", help='Sequencing technology metadata.')

# Download Options
DEFAULT_BATCH <- 1000
DEFAULT_RETRIES <- 2
DEFAULT_SLEEP_MIN <- 5
DEFAULT_SLEEP_MAX <- 10
args_download = parser$add_argument_group('DOWNLOAD OPTIONS')
args_download$add_argument('--batch', type='integer', default=DEFAULT_BATCH, help=paste("Batch size when downloading sequences and metadata. (default:", DEFAULT_BATCH, ")"))
args_download$add_argument('--max-records', type='integer', help="Limit the number of records to the first N in the query. (default: no limit)")
args_download$add_argument('--retries', type='integer', default=DEFAULT_RETRIES, help=paste("If an error is encountered, retry this number of times before exiting. (default:", DEFAULT_RETRIES, ")"))
args_download$add_argument('--sleep-min', type='integer', default=DEFAULT_SLEEP_MIN, help=paste("Minimum number of seconds to sleep in between HTTP requests. (default:", DEFAULT_SLEEP_MIN, ")"))
args_download$add_argument('--sleep-max', type='integer', default=DEFAULT_SLEEP_MAX, help=paste("Maximum number of seconds to sleep in between HTTP requests.(default:", DEFAULT_SLEEP_MAX, ")"))

# Search Options
args_search = parser$add_argument_group('SEARCH OPTIONS')
args_search$add_argument('--aa-substitutions',         default=NULL, type="character",    help='Amino acid substitutions.')
args_search$add_argument('--accessions',               default=NULL, type="character",    help='Path to a txt file of GISAID accessions, new-line separated.')
args_search$add_argument('--collection-date-complete', action="store_true",               help='Complete collection date.')
args_search$add_argument('--complete',                 action="store_true",               help='Complete genomes.')
args_search$add_argument('--from',                     default=NULL, type="character",    help='Collected on or after this date.')
args_search$add_argument('--from-subm',                default=NULL, type="character",    help='Submitted on or after this date.')
args_search$add_argument('--high-coverage',            action="store_true",               help='High coverage records.')
args_search$add_argument('--lineage',                  default=NULL, type="character",    help="Lineage. For EpiPox, must also include clade (ex. '--lineage KP.3.1', '--lineage IIb A.1').")
args_search$add_argument('--location',                 default=NULL, type="character",    help='Collected in this location.')
args_search$add_argument('--low-coverage-excl',        action="store_true",               help='Exclude low coverage records.')
args_search$add_argument('--nucl-mutation',            default=NULL, type="character",    help='Nucleotide mutations.')
args_search$add_argument('--subtype',                  default=NULL, type="character",    help='EpiRSV subtype.')
args_search$add_argument('--text',                     default=NULL, type="character",    help='Path to a txt file for plain text search.')
args_search$add_argument('--to',                       default=NULL, type="character",    help='Collected on or before this date.')
args_search$add_argument('--to-subm',                  default=NULL, type="character",    help='Submitted on or before this date.')
args_search$add_argument('--variant',                 default=NULL, type="character",     help='EpiCoV variant.')
args_search$add_argument('--virus-name',               default=NULL, type="character",    help='Virus name.')

# Other Options
args_other = parser$add_argument_group('OTHER OPTIONS')
DEFAULT_VERBOSITY <- 1
args_other$add_argument('--debug',           action="store_true", help='Show debug log messages.')
args_other$add_argument('--verbosity', "-v", type="integer",  default=DEFAULT_VERBOSITY, help="Set verbosity level of logging (ex. '-v 1', '-v 2').")
args_other$add_argument('--version',         action="store_true", help='Display GISAIDR version.')

args <- commandArgs(trailingOnly = TRUE)
opt <- parser$parse_args(args)

# -------------------------------------------------------------------------
# Parse arguments

if (length(args) == 0){
    parser$print_help()
    quit(status=0)
}

if (opt$version){
    cat(paste0("GISAIDR v", VERSION, "\n"))
    quit(status=0)
}

if (opt$debug){
    Sys.setenv(GISAIDR_DEBUG = 1)
}
if (opt$verbosity){
    Sys.setenv(GISAIDR_VERBOSITY = opt$verbosity)
}

if (is.null(opt$database)){
    GISAIDR::log.error(paste("--database is required. Please provide a GISAID database name (", paste(DATABASES, collapse=", "), ")."))
    quit(status=1)
}

if (!opt$database %in% DATABASES){
    GISAIDR::log.error(paste0("--database ", opt$database, " is not implemented in GISAIDR v", VERSION, ". Please select one of the following: ", paste(DATABASES, collapse=", ")))
    quit(status=1)
}

if (is.null(opt$credentials)){
    GISAIDR::log.error(paste("--credentials is required. Please provide GISAID credentials in a yaml file."))
    quit(status=1)
}


if (!"GISAIDR_USERNAME" %in% names(Sys.getenv()) && !"GISAIDR_PASSWORD" %in% names(Sys.getenv()) && is.null(opt$credentials)){
    GISAIDR::log.error("Missing credentials. Please define the environment variables:
    export GISAIDR_USERNAME='yourUsername'
    export GISAIDR_PASSWORD='yourPassword'

    Or provide a credentials.yml file with your GISAID username and password.\n
    GISAIDR_USERNAME: \"yourUsername\"
    GISAIDR_PASSWORD: \"yourPassword\"")
    quit(status=1)
}

if (is.null(opt$credentials) || !file.exists(opt$credentials)){
    GISAIDR::log.error(paste("--credentials file does not exist:", opt$credentials))
    quit(status=1)
}

if (!is.null(opt$text) && !file.exists(opt$text)){
    GISAIDR::log.error(paste("--text file does not exist:", opt$text))
    quit(status=1)
}

if (!is.null(opt$accessions) && !file.exists(opt$accessions)){
    GISAIDR::log.error(paste("--accessions file does not exist:", opt$accessions))
    quit(status=1)
}

if (!is.null(opt$from) && !grepl(DATE_REGEX, opt$from)){
    GISAIDR::log.error(paste0("'--from ", opt$from, "' does not match the format '--from YYYY-MM-DD'."))
    quit(status=1)
}

if (!is.null(opt$to) && !grepl(DATE_REGEX, opt$to)){
    GISAIDR::log.error(paste("--from", opt$to, "does not match the format  '--to YYYY-MM-DD'."))
    quit(status=1)
}

if (!is.null(opt$from_subm) && !grepl(DATE_REGEX, opt$from_subm)){
    GISAIDR::log.error(paste("--from-subm", opt$from_subm, "does not match the format  '--from-subm YYYY-MM-DD'."))
    quit(status=1)
}

if (!is.null(opt$to_subm) && !grepl(DATE_REGEX, opt$to_subm)){
    GISAIDR::log.error(paste("--to-subm", opt$to_subm, "does not match the format  '--to-subm YYYY-MM-DD'."))
    quit(status=1)
}

# ??? Is lineage only for EpiCoV? I though also mpox?
# if (!is.null(opt$lineage) && opt$database != "EpiCoV"){
#     GISAIDR::log.error(paste("--lineage", opt$lineage, "is only implemented for the EpiCoV database."))
#     quit(status=1)
# }

if (!is.null(opt$variant) && opt$database != "EpiCoV"){
    GISAIDR::log.error(paste("--variant", opt$variant, "is only implemented for the EpiCoV database."))
    quit(status=1)
}

if (!is.null(opt$text) && opt$database != "EpiCoV"){
    GISAIDR::log.error(paste("--text search is only available for the EpiCoV database. Maybe you would like to try an --accessions file?"))
    quit(status=1)
}

if (!is.null(opt$nucl_mutation) && opt$database != "EpiCoV"){
    GISAIDR::log.error(paste("--nucl-mutation is only available for the EpiCoV database."))
    quit(status=1)
}

if (!is.null(opt$subtype) && opt$database != "EpiRSV"){
    GISAIDR::log.error(paste("--subtype is only available for the EpiRSV database."))
    quit(status=1)
}

if (opt$augur_input && opt$database != "EpiCoV"){
    GISAIDR::log.error(paste("--augur-input is only available for the EpiCoV database."))
    quit(status=1)
}

# No output chosen
if (!opt$augur_input && !opt$dates_and_location &&!opt$ids && !opt$patient_status && !opt$sequencing_technology && !opt$sequences){
    GISAIDR::log.error(paste("At least one output must be selected from ids, metadata, and sequences. Please see OUTPUT OPTIONS with --help."))
    quit(status=1)
}

# -------------------------------------------------------------------------
# Input/Output

GISAIDR::log.info("Begin.")

GISAIDR::log.info(sprintf("HTTP requests will sleep for %s to %s seconds.", opt$sleep_min, opt$sleep_max))
Sys.setenv(GISAIDR_SLEEP_MIN = opt$sleep_min)
Sys.setenv(GISAIDR_SLEEP_MAX = opt$sleep_max)

# augur_input and sequences are redundant
if(opt$augur_input && opt$sequences){
    log.warn("Download types --augur-input and --sequences are redundant. Skipping separate sequences download.")
    opt$sequences <- FALSE
}

if (!is.null(opt$prefix)){ 
    ids_file_path       <- paste0(opt$prefix, ".ids.txt")
    metadata_file_path  <- paste0(opt$prefix, ".metadata.tsv")
    sequences_file_path <- paste0(opt$prefix, ".sequences.fasta")
} else {
    ids_file_path       <- "ids.txt"
    metadata_file_path  <- "metadata.tsv"
    sequences_file_path <- "sequences.fasta"
}

# Clean up existing output files, so we can continously write to them as we batch download
if (opt$augur_input || opt$dates_and_location || opt$patient_status || opt$sequencing_technology){
    if (file.exists(metadata_file_path)) {
        GISAIDR::log.info(paste("Removing existing metadata file:", metadata_file_path))
        invisible(file.remove(metadata_file_path))
    }
}
if (opt$augur_input || opt$sequences) {
    if (file.exists(sequences_file_path)) { 
        GISAIDR::log.info(paste("Removing existing sequences file:", sequences_file_path))
        invisible(file.remove(sequences_file_path)) 
    }
    # We're going to manually write to the sequences fasta as we process batches
    # To be determined if this is more/less efficient than other line writing methods    
    sequences_file <- file(sequences_file_path, open = "a")
}
if (opt$augur_input){
    augur_input_dir <- "gisaidr_augur_input_tmp"
    if (dir.exists(augur_input_dir)){
        GISAIDR::log.info(paste("Removing existing augur input directory:", augur_input_dir))
        unlink(augur_input_dir, recursive=TRUE)
    }
}
if (opt$ids) {
    if (file.exists(ids_file_path)) { 
        GISAIDR::log.info(paste("Removing existing ids file:", ids_file_path))
        invisible(file.remove(ids_file_path)) 
    }
}

# -------------------------------------------------------------------------
# Authenticate with GISAID

if (!is.null(opt$credentials)){
    GISAIDR::log.info(paste("Reading GISAID credentials file:", opt$credentials))
    credentials <- yaml::read_yaml(opt$credentials)
    username    <- credentials$GISAIDR_USERNAME
    password    <- credentials$GISAIDR_PASSWORD
} else {
    username = Sys.getenv("GISAIDR_USERNAME")
    password = Sys.getenv("GISAIDR_PASSWORD")
}

GISAIDR::log.info(paste("Authenticating with GISAID database:", opt$database))

num_retries <- 0
while(num_retries <= opt$retries){
    num_retries <- num_retries + 1
    # if download fails, we'll log back in and update credentials
    tryCatch({
        credentials <- GISAIDR::login(username, password, opt$database)
        # Break out of the while loop of retries if successful
        break
    },
    # errors
    error=function(msg) {
        GISAIDR::log.error(msg)
        if (grepl("Server error", msg)){
            if (num_retries >= opt$retries){
                log.info(paste("Authentication failed, no retries remaining:", num_retries, "/", opt$retries))
                quit(status=1)
            }
            GISAIDR::log.info(paste("Authentication failed, retry:", num_retries, "/", opt$retries))
            return(credentials)
        } else {
            GISAIDR::log.error("Unhandled error, exiting.")
            quit(status=1)
        }
    })
}

credentials_display <- paste(unlist(lapply(names(credentials), function(name){paste0(name, "=", credentials[[name]])})), collapse=" ")
log.debug(paste("credentials:", credentials_display))

# -------------------------------------------------------------------------
# Query

if (!is.null(opt$accessions)){
    log.info(paste("Reading GISAID accessions file:", opt$accessions))
    accession_ids <- readLines(opt$accessions)
} else {
    log.info(paste("Querying GISAID:", opt$database))

    # Dynamically create the query from the command-line arguments
    query_args <- c()
    query_args$fast <- TRUE
    query_args$credentials <- credentials
    if (!is.null(opt$aa_substitution))          { query_args$aa_substitution <- opt$aa_substitution}
    if (!is.null(opt$collection_date_complete)) { query_args$collection_date_complete <- opt$collection_date_complete}    
    if (!is.null(opt$complete))                 { query_args$complete <- opt$complete}
    if (!is.null(opt$from))                     { query_args$from       <- opt$from}
    if (!is.null(opt$from_subm))                { query_args$from_subm  <- opt$from_subm}
    if (!is.null(opt$high_coverage))            { query_args$high_coverage <- opt$high_coverage}
    if (!is.null(opt$lineage))                  { query_args$lineage    <- opt$lineage}    
    if (!is.null(opt$location))                 { query_args$location   <- opt$location}
    if (!is.null(opt$low_coverage_excl))        { query_args$low_coverage_excl <- opt$low_coverage_excl}
    if (!is.null(opt$nucl_mutation))            { query_args$nucl_mutation <- opt$nucl_mutation}
    if (!is.null(opt$subtype))                  { query_args$subtype    <- opt$subtype}    
    if (!is.null(opt$text))                     { query_args$text <- paste(readLines(opt$text), collapse = "\n") }
    if (!is.null(opt$to))                       { query_args$to         <- opt$to}
    if (!is.null(opt$to_subm))                  { query_args$to_subm    <- opt$to_subm}
    if (!is.null(opt$variant))                  { query_args$variant    <- opt$variant}
    if (!is.null(opt$virus_name))               { query_args$virus_name <- opt$virus_name}

    query_result <- do.call(GISAIDR::query, as.list(query_args))

    # Sort by accession id (newest submissions to oldest)
    query_result$accession_id <- sort(query_result[["accession_id"]], decreasing = TRUE)
    accession_ids <- query_result[["accession_id"]]
}

log.info(paste("Found", length(accession_ids), "records."))

if (!is.null(opt$max_records) && opt$max_records >= 0){
    log.info(paste0("Restricting the number of records to --max-records ", opt$max_records, "."))
    accession_ids <- head(accession_ids, n=opt$max_records)
}

if(opt$ids){
    log.info(paste("Writing accession IDs to file:", ids_file_path))
    sink(ids_file_path)
    cat(accession_ids, sep="\n")
    sink()
}

if (length(accession_ids) == 0 ){
    GISAIDR::log.info("Done")
    quit(status=0)
}

# -------------------------------------------------------------------------
# Download

# iterate through the accessions in batch chunks
if (length(accession_ids) < opt$batch){ opt$batch <- length(accession_ids)}
total_batches <- ceiling(length(accession_ids) / opt$batch)
num_batches   <- 0

GISAIDR::log.info(paste0("Downloading ", total_batches, " batch(es) of size ", opt$batch, "."))

for(start in seq(1, length(accession_ids), opt$batch)){

    num_batches <- num_batches + 1

    # Figure out our batch size for the current iteration
    end <- start + opt$batch - 1
    if (end > length(accession_ids)){end <- length(accession_ids)}
    GISAIDR::log.info(paste("Batch:", num_batches, "/", total_batches))
    batch_accession_ids <- accession_ids[start:end]

    num_retries <- 0
    while(num_retries <= opt$retries){

        num_retries <- num_retries + 1
        # if download fails, we'll log back in and update credentials
        credentials <- tryCatch({
            # Configure download args and types
            download_args <- c()
            download_args$credentials           <- credentials
            download_args$list_of_accession_ids <- batch_accession_ids

            download_types <- c()
            if (opt$dates_and_location)   { download_types <- c(download_types, "dates_and_location") }
            if (opt$patient_status)       { download_types <- c(download_types, "patient_status") }
            if (opt$sequencing_technology){ download_types <- c(download_types, "sequencing_technology") }
            if (opt$augur_input)          { download_types <- c(download_types, "augur_input") }
            if (opt$sequences)            { download_types <- c(download_types, "sequences") }

            for (download_type in download_types){ download_args[[download_type]] <- TRUE }

            # Download files
            download_results <- do.call(GISAIDR::download_files, as.list(download_args))

            # Merge metadata files
            metadata  <- NULL            
            for (download_type in download_types){

                if (download_type == "sequences"){ next }
                result <- download_results[[download_type]]
                if (download_type == "augur_input"){
                    df <- result$metadata
                    join_col <- "gisaid_epi_isl"
                } else {
                    df <- result
                    join_col <- "Accession ID"
                }
                if (is.null(metadata)){
                    metadata <- df
                } else {
                    cols <- unique(c(join_col, colnames(df)[!colnames(df) %in% colnames(metadata)]))
                    metadata <- merge(metadata, df[cols], by.x="Accession ID", by.y = join_col)
                }
            }
            # Write merged metadata
            if (!is.null(metadata)){
                # Put newest submissions first if possible
                if ("gisaid_epi_isl" %in% colnames(metadata)){ order_by <- "gisaid_epi_isl" } 
                else { order_by <- "Accession ID"}
                metadata <- metadata[order(metadata[[order_by]], decreasing=TRUE), ]
                # Append to output file
                suppressWarnings(write.table(
                    metadata, 
                    metadata_file_path,
                    row.names = FALSE, 
                    quote = FALSE, 
                    sep = "\t", 
                    col.names = !file.exists(metadata_file_path), 
                    append = TRUE
                ))
            }

            # Write sequences to file, either from --sequences or --augur-input
            sequences <- NULL
            if (!is.null(download_results$sequences)){
                sequences <- download_results$sequences
            } else if (!is.null(download_results$augur) && !is.null(download_results$augur$sequences)){
                sequences <- download_results$augur$sequences
            }
            if (!is.null(sequences)){
                cat(sequences, file=sequences_file, append=TRUE)
            }            

            # Break out of the while loop of download retries, continue on to next batch
            break
        },
        # errors
        error=function(msg) {
            GISAIDR::log.error(msg)
            if (grepl("Please login again", msg)){
                if (num_retries >= opt$retries){
                    log.info(paste("Download failed, no retries remaining:", num_retries, "/", opt$retries))
                    quit(status=1)
                }
                GISAIDR::log.info(paste("Download failed, retry:", num_retries, "/", opt$retries))
                GISAIDR::log.info(paste("Re-Authenticating with GISAID:", opt$database))
                credentials <- GISAIDR::login(username, password, opt$database)
                return(credentials)
            } else {
                GISAIDR::log.error("Unhandled error, exiting.")
                quit(status=1)
            }
        })
    }
}

if (!is.null(opt$order_by)){
    GISAIDR::log.info(paste("Ordering metadata by column:", opt$order_by))
    metadata <- metadata <- read.csv(metadata_file_path, sep="\t", quote="", check.names=FALSE)
    metadata <- metadata[order(metadata[[opt$order_by]], decreasing=opt$order_by_rev), ]
    write.table(metadata, metadata_file_path, row.names = FALSE, quote = FALSE, sep = "\t")
}

if (opt$augur_input || opt$sequences) {
    close(sequences_file)
}

GISAIDR::log.info("Done")
